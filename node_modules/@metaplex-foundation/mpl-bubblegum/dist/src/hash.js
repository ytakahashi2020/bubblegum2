"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashAssetData = exports.hashCollection = exports.hashMetadataCreators = exports.hashMetadataDataV2 = exports.hashMetadataData = exports.hashMetadataV2 = exports.hashMetadata = exports.hashLeafV2 = exports.hashLeaf = exports.hash = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const serializers_1 = require("@metaplex-foundation/umi/serializers");
const sha3_1 = require("@noble/hashes/sha3");
const generated_1 = require("./generated");
const leafAssetId_1 = require("./leafAssetId");
const flags_1 = require("./flags");
function hash(input) {
    return (0, sha3_1.keccak_256)(Array.isArray(input) ? (0, serializers_1.mergeBytes)(input) : input);
}
exports.hash = hash;
function hashLeaf(context, input) {
    const delegate = input.delegate ?? input.owner;
    const nftVersion = input.nftVersion ?? 1;
    const [leafAssetId] = (0, leafAssetId_1.findLeafAssetIdPda)(context, {
        merkleTree: input.merkleTree,
        leafIndex: input.leafIndex,
    });
    return hash([
        (0, serializers_1.u8)().serialize(nftVersion),
        (0, serializers_1.publicKey)().serialize(leafAssetId),
        (0, serializers_1.publicKey)().serialize(input.owner),
        (0, serializers_1.publicKey)().serialize(delegate),
        (0, serializers_1.u64)().serialize(input.leafIndex),
        hashMetadata(input.metadata),
    ]);
}
exports.hashLeaf = hashLeaf;
function hashLeafV2(context, input) {
    const delegate = input.delegate ?? input.owner;
    const nftVersion = input.nftVersion ?? 2;
    const [leafAssetId] = (0, leafAssetId_1.findLeafAssetIdPda)(context, {
        merkleTree: input.merkleTree,
        leafIndex: input.leafIndex,
    });
    const collectionOption = (0, umi_1.isOption)(input.metadata.collection)
        ? input.metadata.collection
        : (0, umi_1.wrapNullable)(input.metadata.collection);
    const collection = (0, umi_1.unwrapOption)(collectionOption, () => (0, umi_1.defaultPublicKey)());
    const flags = input.flags ?? flags_1.LeafSchemaV2Flags.None;
    if (!(0, flags_1.isValidLeafSchemaV2Flags)(flags)) {
        throw new Error(`Invalid flags value: ${flags}`);
    }
    return hash([
        (0, serializers_1.u8)().serialize(nftVersion),
        (0, serializers_1.publicKey)().serialize(leafAssetId),
        (0, serializers_1.publicKey)().serialize(input.owner),
        (0, serializers_1.publicKey)().serialize(delegate),
        (0, serializers_1.u64)().serialize(input.leafIndex),
        hashMetadataV2(input.metadata),
        hashCollection(collection),
        hashAssetData(input.assetData),
        (0, serializers_1.u8)().serialize(flags),
    ]);
}
exports.hashLeafV2 = hashLeafV2;
function hashMetadata(metadata) {
    return (0, serializers_1.mergeBytes)([
        hashMetadataData(metadata),
        hashMetadataCreators(metadata.creators),
    ]);
}
exports.hashMetadata = hashMetadata;
function hashMetadataV2(metadata) {
    return (0, serializers_1.mergeBytes)([
        hashMetadataDataV2(metadata),
        hashMetadataCreators(metadata.creators),
    ]);
}
exports.hashMetadataV2 = hashMetadataV2;
function hashMetadataData(metadata) {
    return hash([
        hash((0, generated_1.getMetadataArgsSerializer)().serialize(metadata)),
        (0, serializers_1.u16)().serialize(metadata.sellerFeeBasisPoints),
    ]);
}
exports.hashMetadataData = hashMetadataData;
function hashMetadataDataV2(metadata) {
    return hash([
        hash((0, generated_1.getMetadataArgsV2Serializer)().serialize(metadata)),
        (0, serializers_1.u16)().serialize(metadata.sellerFeeBasisPoints),
    ]);
}
exports.hashMetadataDataV2 = hashMetadataDataV2;
function hashMetadataCreators(creators) {
    return hash((0, serializers_1.array)((0, generated_1.getCreatorSerializer)(), { size: 'remainder' }).serialize(creators));
}
exports.hashMetadataCreators = hashMetadataCreators;
function hashCollection(collection) {
    return hash((0, serializers_1.publicKey)().serialize(collection));
}
exports.hashCollection = hashCollection;
function hashAssetData(assetData) {
    let dataBytes;
    if (assetData === undefined || assetData === null) {
        dataBytes = new Uint8Array(0);
    }
    else if (typeof assetData === 'string') {
        dataBytes = new TextEncoder().encode(assetData);
    }
    else {
        dataBytes = assetData;
    }
    return hash(dataBytes);
}
exports.hashAssetData = hashAssetData;
//# sourceMappingURL=hash.js.map