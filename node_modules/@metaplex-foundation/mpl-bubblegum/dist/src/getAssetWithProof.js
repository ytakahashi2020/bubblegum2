"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAssetWithProof = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const spl_account_compression_1 = require("@metaplex-foundation/spl-account-compression");
const flags_1 = require("./flags");
const generated_1 = require("./generated");
const getAssetWithProof = async (context, assetId, options) => {
    const [rpcAsset, rpcAssetProof] = await Promise.all([
        context.rpc.getAsset(assetId),
        context.rpc.getAssetProof(assetId),
    ]);
    let { proof } = rpcAssetProof;
    if (options?.truncateCanopy) {
        const merkleTreeAccount = await (0, spl_account_compression_1.fetchMerkleTree)(context, rpcAssetProof.tree_id);
        const canopyDepth = Math.log2(merkleTreeAccount.canopy.length + 2) - 1;
        proof = rpcAssetProof.proof.slice(0, canopyDepth === 0 ? undefined : -canopyDepth);
    }
    const collectionString = (rpcAsset.grouping ?? []).find((group) => group.group_key === 'collection')?.group_value;
    const metadata = {
        name: rpcAsset.content?.metadata?.name ?? '',
        symbol: rpcAsset.content?.metadata?.symbol ?? '',
        uri: rpcAsset.content?.json_uri,
        sellerFeeBasisPoints: rpcAsset.royalty?.basis_points,
        primarySaleHappened: rpcAsset.royalty?.primary_sale_happened,
        isMutable: rpcAsset.mutable,
        editionNonce: (0, umi_1.wrapNullable)(rpcAsset.supply?.edition_nonce),
        tokenStandard: (0, umi_1.some)(generated_1.TokenStandard.NonFungible),
        collection: collectionString
            ? (0, umi_1.some)({ key: (0, umi_1.publicKey)(collectionString), verified: true })
            : (0, umi_1.none)(),
        uses: (0, umi_1.none)(),
        tokenProgramVersion: generated_1.TokenProgramVersion.Original,
        creators: rpcAsset.creators,
    };
    const collectionHashBytes = rpcAsset.compression.collection_hash
        ? (0, umi_1.publicKeyBytes)(rpcAsset.compression.collection_hash)
        : undefined;
    const assetDataHashBytes = rpcAsset.compression.asset_data_hash
        ? (0, umi_1.publicKeyBytes)(rpcAsset.compression.asset_data_hash)
        : undefined;
    const rawFlags = rpcAsset.compression.flags;
    const flagsValue = (0, flags_1.isValidLeafSchemaV2Flags)(rawFlags)
        ? rawFlags
        : undefined;
    return {
        leafOwner: rpcAsset.ownership.owner,
        leafDelegate: rpcAsset.ownership.delegate
            ? rpcAsset.ownership.delegate
            : rpcAsset.ownership.owner,
        merkleTree: rpcAssetProof.tree_id,
        root: (0, umi_1.publicKeyBytes)(rpcAssetProof.root),
        dataHash: (0, umi_1.publicKeyBytes)(rpcAsset.compression.data_hash),
        creatorHash: (0, umi_1.publicKeyBytes)(rpcAsset.compression.creator_hash),
        collection_hash: collectionHashBytes,
        asset_data_hash: assetDataHashBytes,
        flags: flagsValue,
        nonce: rpcAsset.compression.leaf_id,
        index: rpcAssetProof.node_index - 2 ** rpcAssetProof.proof.length,
        proof,
        metadata,
        rpcAsset,
        rpcAssetProof,
    };
};
exports.getAssetWithProof = getAssetWithProof;
//# sourceMappingURL=getAssetWithProof.js.map