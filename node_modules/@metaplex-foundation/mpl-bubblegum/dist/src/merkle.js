"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMerkleProofAtIndex = exports.getMerkleProof = exports.getMerkleRoot = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const sha3_1 = require("@noble/hashes/sha3");
const merkletreejs_1 = require("merkletreejs");
/**
 * Creates a Merkle Tree from the provided data.
 */
const getMerkleTree = (leaves, maxDepth) => new merkletreejs_1.MerkleTree([
    ...leaves.map((leaf) => (0, umi_1.publicKeyBytes)(leaf)),
    ...Array(2 ** maxDepth - leaves.length)
        .fill(0)
        .map(() => new Uint8Array(32).fill(0)),
], sha3_1.keccak_256);
/**
 * Creates a Merkle Root from the provided data.
 *
 * This root provides a short identifier for the
 * provided data that is unique and deterministic.
 * This means, we can use this root to verify that
 * a given data is part of the original data set.
 */
const getMerkleRoot = (leaves, maxDepth) => (0, umi_1.publicKey)(getMerkleTree(leaves, maxDepth).getRoot());
exports.getMerkleRoot = getMerkleRoot;
/**
 * Creates a Merkle Proof for a given data item.
 *
 * This proof can be used to verify that the given
 * data item is part of the original data set.
 */
const getMerkleProof = (leaves, maxDepth, leaf, index) => getMerkleTree(leaves, maxDepth)
    .getProof(Buffer.from((0, umi_1.publicKeyBytes)(leaf)), index)
    .map((proofItem) => (0, umi_1.publicKey)(proofItem.data));
exports.getMerkleProof = getMerkleProof;
/**
 * Creates a Merkle Proof for a data item at a given index.
 *
 * This proof can be used to verify that the data item at
 * the given index is part of the original data set.
 */
const getMerkleProofAtIndex = (leaves, maxDepth, index) => (0, exports.getMerkleProof)(leaves, maxDepth, leaves[index], index);
exports.getMerkleProofAtIndex = getMerkleProofAtIndex;
//# sourceMappingURL=merkle.js.map