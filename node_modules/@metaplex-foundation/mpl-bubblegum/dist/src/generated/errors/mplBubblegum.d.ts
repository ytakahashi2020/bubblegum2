/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */
import { Program, ProgramError } from '@metaplex-foundation/umi';
/** AssetOwnerMismatch: Asset Owner Does not match */
export declare class AssetOwnerMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** PublicKeyMismatch: PublicKeyMismatch */
export declare class PublicKeyMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** HashingMismatch: Hashing Mismatch Within Leaf Schema */
export declare class HashingMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** UnsupportedSchemaVersion: Unsupported Schema Version */
export declare class UnsupportedSchemaVersionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CreatorShareTotalMustBe100: Creator shares must sum to 100 */
export declare class CreatorShareTotalMustBe100Error extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** DuplicateCreatorAddress: No duplicate creator addresses in metadata */
export declare class DuplicateCreatorAddressError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CreatorDidNotVerify: Creator did not verify the metadata */
export declare class CreatorDidNotVerifyError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CreatorNotFound: Creator not found in creator Vec */
export declare class CreatorNotFoundError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** NoCreatorsPresent: No creators in creator Vec */
export declare class NoCreatorsPresentError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CreatorHashMismatch: User-provided creator Vec must result in same user-provided creator hash */
export declare class CreatorHashMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** DataHashMismatch: User-provided metadata must result in same user-provided data hash */
export declare class DataHashMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CreatorsTooLong: Creators list too long */
export declare class CreatorsTooLongError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MetadataNameTooLong: Name in metadata is too long */
export declare class MetadataNameTooLongError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MetadataSymbolTooLong: Symbol in metadata is too long */
export declare class MetadataSymbolTooLongError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MetadataUriTooLong: Uri in metadata is too long */
export declare class MetadataUriTooLongError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MetadataBasisPointsTooHigh: Basis points in metadata cannot exceed 10000 */
export declare class MetadataBasisPointsTooHighError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** TreeAuthorityIncorrect: Tree creator or tree delegate must sign. */
export declare class TreeAuthorityIncorrectError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InsufficientMintCapacity: Not enough unapproved mints left */
export declare class InsufficientMintCapacityError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** NumericalOverflowError: NumericalOverflowError */
export declare class NumericalOverflowErrorError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** IncorrectOwner: Incorrect account owner */
export declare class IncorrectOwnerError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CollectionCannotBeVerifiedInThisInstruction: Cannot Verify Collection in this Instruction */
export declare class CollectionCannotBeVerifiedInThisInstructionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CollectionNotFound: Collection Not Found on Metadata */
export declare class CollectionNotFoundError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** AlreadyVerified: Collection item is already verified. */
export declare class AlreadyVerifiedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** AlreadyUnverified: Collection item is already unverified. */
export declare class AlreadyUnverifiedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** UpdateAuthorityIncorrect: Incorrect leaf metadata update authority. */
export declare class UpdateAuthorityIncorrectError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** LeafAuthorityMustSign: This transaction must be signed by either the leaf owner or leaf delegate */
export declare class LeafAuthorityMustSignError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CollectionMustBeSized: Collection Not Compatable with Compression, Must be Sized */
export declare class CollectionMustBeSizedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MetadataMintMismatch: Metadata mint does not match collection mint */
export declare class MetadataMintMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidCollectionAuthority: Invalid collection authority */
export declare class InvalidCollectionAuthorityError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidDelegateRecord: Invalid delegate record pda derivation */
export declare class InvalidDelegateRecordError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CollectionMasterEditionAccountInvalid: Edition account doesnt match collection */
export declare class CollectionMasterEditionAccountInvalidError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CollectionMustBeAUniqueMasterEdition: Collection Must Be a Unique Master Edition v2 */
export declare class CollectionMustBeAUniqueMasterEditionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** UnknownExternalError: Could not convert external error to BubblegumError */
export declare class UnknownExternalErrorError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** DecompressionDisabled: Decompression is disabled for this tree. */
export declare class DecompressionDisabledError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingCollectionMintAccount: Missing collection mint account */
export declare class MissingCollectionMintAccountError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingCollectionMetadataAccount: Missing collection metadata account */
export declare class MissingCollectionMetadataAccountError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CollectionMismatch: Collection mismatch */
export declare class CollectionMismatchError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MetadataImmutable: Metadata not mutable */
export declare class MetadataImmutableError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** PrimarySaleCanOnlyBeFlippedToTrue: Can only update primary sale to true */
export declare class PrimarySaleCanOnlyBeFlippedToTrueError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CreatorDidNotUnverify: Creator did not unverify the metadata */
export declare class CreatorDidNotUnverifyError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidTokenStandard: Only NonFungible standard is supported */
export declare class InvalidTokenStandardError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidCanopySize: Canopy size should be set bigger for this tree */
export declare class InvalidCanopySizeError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidLogWrapper: Invalid log wrapper program */
export declare class InvalidLogWrapperError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidCompressionProgram: Invalid compression program */
export declare class InvalidCompressionProgramError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** LeafMustBeDelegated: Leaf must be delegated to someone other than the leaf owner */
export declare class LeafMustBeDelegatedError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** AssetIsFrozen: Asset is frozen */
export declare class AssetIsFrozenError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** AssetIsNonTransferable: Asset is non-transferable */
export declare class AssetIsNonTransferableError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** InvalidAuthority: Invalid authority */
export declare class InvalidAuthorityError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CollectionIsFrozen: Collection is frozen */
export declare class CollectionIsFrozenError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** CollectionMustHaveBubblegumPlugin: Core collections must have the Bubblegum V2 plugin on them */
export declare class CollectionMustHaveBubblegumPluginError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** NotAvailable: Feature not currently available */
export declare class NotAvailableError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingCollectionAccount: Missing collection account */
export declare class MissingCollectionAccountError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** AssetDataLengthTooLong: Asset data length too long */
export declare class AssetDataLengthTooLongError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** AlreadyInCollection: Item is already in the collection */
export declare class AlreadyInCollectionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** AlreadyNotInCollection: Item is already not in a collection */
export declare class AlreadyNotInCollectionError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** MissingMplCoreCpiSignerAccount: Missing mpl-core CPI signer account */
export declare class MissingMplCoreCpiSignerAccountError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/** AssetIsNotFrozen: Asset is not frozen */
export declare class AssetIsNotFrozenError extends ProgramError {
    readonly name: string;
    readonly code: number;
    constructor(program: Program, cause?: Error);
}
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 */
export declare function getMplBubblegumErrorFromCode(code: number, program: Program, cause?: Error): ProgramError | null;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 */
export declare function getMplBubblegumErrorFromName(name: string, program: Program, cause?: Error): ProgramError | null;
