"use strict";
/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectionMustHaveBubblegumPluginError = exports.CollectionIsFrozenError = exports.InvalidAuthorityError = exports.AssetIsNonTransferableError = exports.AssetIsFrozenError = exports.LeafMustBeDelegatedError = exports.InvalidCompressionProgramError = exports.InvalidLogWrapperError = exports.InvalidCanopySizeError = exports.InvalidTokenStandardError = exports.CreatorDidNotUnverifyError = exports.PrimarySaleCanOnlyBeFlippedToTrueError = exports.MetadataImmutableError = exports.CollectionMismatchError = exports.MissingCollectionMetadataAccountError = exports.MissingCollectionMintAccountError = exports.DecompressionDisabledError = exports.UnknownExternalErrorError = exports.CollectionMustBeAUniqueMasterEditionError = exports.CollectionMasterEditionAccountInvalidError = exports.InvalidDelegateRecordError = exports.InvalidCollectionAuthorityError = exports.MetadataMintMismatchError = exports.CollectionMustBeSizedError = exports.LeafAuthorityMustSignError = exports.UpdateAuthorityIncorrectError = exports.AlreadyUnverifiedError = exports.AlreadyVerifiedError = exports.CollectionNotFoundError = exports.CollectionCannotBeVerifiedInThisInstructionError = exports.IncorrectOwnerError = exports.NumericalOverflowErrorError = exports.InsufficientMintCapacityError = exports.TreeAuthorityIncorrectError = exports.MetadataBasisPointsTooHighError = exports.MetadataUriTooLongError = exports.MetadataSymbolTooLongError = exports.MetadataNameTooLongError = exports.CreatorsTooLongError = exports.DataHashMismatchError = exports.CreatorHashMismatchError = exports.NoCreatorsPresentError = exports.CreatorNotFoundError = exports.CreatorDidNotVerifyError = exports.DuplicateCreatorAddressError = exports.CreatorShareTotalMustBe100Error = exports.UnsupportedSchemaVersionError = exports.HashingMismatchError = exports.PublicKeyMismatchError = exports.AssetOwnerMismatchError = void 0;
exports.getMplBubblegumErrorFromName = exports.getMplBubblegumErrorFromCode = exports.AssetIsNotFrozenError = exports.MissingMplCoreCpiSignerAccountError = exports.AlreadyNotInCollectionError = exports.AlreadyInCollectionError = exports.AssetDataLengthTooLongError = exports.MissingCollectionAccountError = exports.NotAvailableError = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const codeToErrorMap = new Map();
const nameToErrorMap = new Map();
/** AssetOwnerMismatch: Asset Owner Does not match */
class AssetOwnerMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Asset Owner Does not match', program, cause);
        this.name = 'AssetOwnerMismatch';
        this.code = 0x1770; // 6000
    }
}
exports.AssetOwnerMismatchError = AssetOwnerMismatchError;
codeToErrorMap.set(0x1770, AssetOwnerMismatchError);
nameToErrorMap.set('AssetOwnerMismatch', AssetOwnerMismatchError);
/** PublicKeyMismatch: PublicKeyMismatch */
class PublicKeyMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('PublicKeyMismatch', program, cause);
        this.name = 'PublicKeyMismatch';
        this.code = 0x1771; // 6001
    }
}
exports.PublicKeyMismatchError = PublicKeyMismatchError;
codeToErrorMap.set(0x1771, PublicKeyMismatchError);
nameToErrorMap.set('PublicKeyMismatch', PublicKeyMismatchError);
/** HashingMismatch: Hashing Mismatch Within Leaf Schema */
class HashingMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Hashing Mismatch Within Leaf Schema', program, cause);
        this.name = 'HashingMismatch';
        this.code = 0x1772; // 6002
    }
}
exports.HashingMismatchError = HashingMismatchError;
codeToErrorMap.set(0x1772, HashingMismatchError);
nameToErrorMap.set('HashingMismatch', HashingMismatchError);
/** UnsupportedSchemaVersion: Unsupported Schema Version */
class UnsupportedSchemaVersionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Unsupported Schema Version', program, cause);
        this.name = 'UnsupportedSchemaVersion';
        this.code = 0x1773; // 6003
    }
}
exports.UnsupportedSchemaVersionError = UnsupportedSchemaVersionError;
codeToErrorMap.set(0x1773, UnsupportedSchemaVersionError);
nameToErrorMap.set('UnsupportedSchemaVersion', UnsupportedSchemaVersionError);
/** CreatorShareTotalMustBe100: Creator shares must sum to 100 */
class CreatorShareTotalMustBe100Error extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Creator shares must sum to 100', program, cause);
        this.name = 'CreatorShareTotalMustBe100';
        this.code = 0x1774; // 6004
    }
}
exports.CreatorShareTotalMustBe100Error = CreatorShareTotalMustBe100Error;
codeToErrorMap.set(0x1774, CreatorShareTotalMustBe100Error);
nameToErrorMap.set('CreatorShareTotalMustBe100', CreatorShareTotalMustBe100Error);
/** DuplicateCreatorAddress: No duplicate creator addresses in metadata */
class DuplicateCreatorAddressError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('No duplicate creator addresses in metadata', program, cause);
        this.name = 'DuplicateCreatorAddress';
        this.code = 0x1775; // 6005
    }
}
exports.DuplicateCreatorAddressError = DuplicateCreatorAddressError;
codeToErrorMap.set(0x1775, DuplicateCreatorAddressError);
nameToErrorMap.set('DuplicateCreatorAddress', DuplicateCreatorAddressError);
/** CreatorDidNotVerify: Creator did not verify the metadata */
class CreatorDidNotVerifyError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Creator did not verify the metadata', program, cause);
        this.name = 'CreatorDidNotVerify';
        this.code = 0x1776; // 6006
    }
}
exports.CreatorDidNotVerifyError = CreatorDidNotVerifyError;
codeToErrorMap.set(0x1776, CreatorDidNotVerifyError);
nameToErrorMap.set('CreatorDidNotVerify', CreatorDidNotVerifyError);
/** CreatorNotFound: Creator not found in creator Vec */
class CreatorNotFoundError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Creator not found in creator Vec', program, cause);
        this.name = 'CreatorNotFound';
        this.code = 0x1777; // 6007
    }
}
exports.CreatorNotFoundError = CreatorNotFoundError;
codeToErrorMap.set(0x1777, CreatorNotFoundError);
nameToErrorMap.set('CreatorNotFound', CreatorNotFoundError);
/** NoCreatorsPresent: No creators in creator Vec */
class NoCreatorsPresentError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('No creators in creator Vec', program, cause);
        this.name = 'NoCreatorsPresent';
        this.code = 0x1778; // 6008
    }
}
exports.NoCreatorsPresentError = NoCreatorsPresentError;
codeToErrorMap.set(0x1778, NoCreatorsPresentError);
nameToErrorMap.set('NoCreatorsPresent', NoCreatorsPresentError);
/** CreatorHashMismatch: User-provided creator Vec must result in same user-provided creator hash */
class CreatorHashMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('User-provided creator Vec must result in same user-provided creator hash', program, cause);
        this.name = 'CreatorHashMismatch';
        this.code = 0x1779; // 6009
    }
}
exports.CreatorHashMismatchError = CreatorHashMismatchError;
codeToErrorMap.set(0x1779, CreatorHashMismatchError);
nameToErrorMap.set('CreatorHashMismatch', CreatorHashMismatchError);
/** DataHashMismatch: User-provided metadata must result in same user-provided data hash */
class DataHashMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('User-provided metadata must result in same user-provided data hash', program, cause);
        this.name = 'DataHashMismatch';
        this.code = 0x177a; // 6010
    }
}
exports.DataHashMismatchError = DataHashMismatchError;
codeToErrorMap.set(0x177a, DataHashMismatchError);
nameToErrorMap.set('DataHashMismatch', DataHashMismatchError);
/** CreatorsTooLong: Creators list too long */
class CreatorsTooLongError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Creators list too long', program, cause);
        this.name = 'CreatorsTooLong';
        this.code = 0x177b; // 6011
    }
}
exports.CreatorsTooLongError = CreatorsTooLongError;
codeToErrorMap.set(0x177b, CreatorsTooLongError);
nameToErrorMap.set('CreatorsTooLong', CreatorsTooLongError);
/** MetadataNameTooLong: Name in metadata is too long */
class MetadataNameTooLongError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Name in metadata is too long', program, cause);
        this.name = 'MetadataNameTooLong';
        this.code = 0x177c; // 6012
    }
}
exports.MetadataNameTooLongError = MetadataNameTooLongError;
codeToErrorMap.set(0x177c, MetadataNameTooLongError);
nameToErrorMap.set('MetadataNameTooLong', MetadataNameTooLongError);
/** MetadataSymbolTooLong: Symbol in metadata is too long */
class MetadataSymbolTooLongError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Symbol in metadata is too long', program, cause);
        this.name = 'MetadataSymbolTooLong';
        this.code = 0x177d; // 6013
    }
}
exports.MetadataSymbolTooLongError = MetadataSymbolTooLongError;
codeToErrorMap.set(0x177d, MetadataSymbolTooLongError);
nameToErrorMap.set('MetadataSymbolTooLong', MetadataSymbolTooLongError);
/** MetadataUriTooLong: Uri in metadata is too long */
class MetadataUriTooLongError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Uri in metadata is too long', program, cause);
        this.name = 'MetadataUriTooLong';
        this.code = 0x177e; // 6014
    }
}
exports.MetadataUriTooLongError = MetadataUriTooLongError;
codeToErrorMap.set(0x177e, MetadataUriTooLongError);
nameToErrorMap.set('MetadataUriTooLong', MetadataUriTooLongError);
/** MetadataBasisPointsTooHigh: Basis points in metadata cannot exceed 10000 */
class MetadataBasisPointsTooHighError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Basis points in metadata cannot exceed 10000', program, cause);
        this.name = 'MetadataBasisPointsTooHigh';
        this.code = 0x177f; // 6015
    }
}
exports.MetadataBasisPointsTooHighError = MetadataBasisPointsTooHighError;
codeToErrorMap.set(0x177f, MetadataBasisPointsTooHighError);
nameToErrorMap.set('MetadataBasisPointsTooHigh', MetadataBasisPointsTooHighError);
/** TreeAuthorityIncorrect: Tree creator or tree delegate must sign. */
class TreeAuthorityIncorrectError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Tree creator or tree delegate must sign.', program, cause);
        this.name = 'TreeAuthorityIncorrect';
        this.code = 0x1780; // 6016
    }
}
exports.TreeAuthorityIncorrectError = TreeAuthorityIncorrectError;
codeToErrorMap.set(0x1780, TreeAuthorityIncorrectError);
nameToErrorMap.set('TreeAuthorityIncorrect', TreeAuthorityIncorrectError);
/** InsufficientMintCapacity: Not enough unapproved mints left */
class InsufficientMintCapacityError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Not enough unapproved mints left', program, cause);
        this.name = 'InsufficientMintCapacity';
        this.code = 0x1781; // 6017
    }
}
exports.InsufficientMintCapacityError = InsufficientMintCapacityError;
codeToErrorMap.set(0x1781, InsufficientMintCapacityError);
nameToErrorMap.set('InsufficientMintCapacity', InsufficientMintCapacityError);
/** NumericalOverflowError: NumericalOverflowError */
class NumericalOverflowErrorError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('NumericalOverflowError', program, cause);
        this.name = 'NumericalOverflowError';
        this.code = 0x1782; // 6018
    }
}
exports.NumericalOverflowErrorError = NumericalOverflowErrorError;
codeToErrorMap.set(0x1782, NumericalOverflowErrorError);
nameToErrorMap.set('NumericalOverflowError', NumericalOverflowErrorError);
/** IncorrectOwner: Incorrect account owner */
class IncorrectOwnerError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Incorrect account owner', program, cause);
        this.name = 'IncorrectOwner';
        this.code = 0x1783; // 6019
    }
}
exports.IncorrectOwnerError = IncorrectOwnerError;
codeToErrorMap.set(0x1783, IncorrectOwnerError);
nameToErrorMap.set('IncorrectOwner', IncorrectOwnerError);
/** CollectionCannotBeVerifiedInThisInstruction: Cannot Verify Collection in this Instruction */
class CollectionCannotBeVerifiedInThisInstructionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Cannot Verify Collection in this Instruction', program, cause);
        this.name = 'CollectionCannotBeVerifiedInThisInstruction';
        this.code = 0x1784; // 6020
    }
}
exports.CollectionCannotBeVerifiedInThisInstructionError = CollectionCannotBeVerifiedInThisInstructionError;
codeToErrorMap.set(0x1784, CollectionCannotBeVerifiedInThisInstructionError);
nameToErrorMap.set('CollectionCannotBeVerifiedInThisInstruction', CollectionCannotBeVerifiedInThisInstructionError);
/** CollectionNotFound: Collection Not Found on Metadata */
class CollectionNotFoundError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Collection Not Found on Metadata', program, cause);
        this.name = 'CollectionNotFound';
        this.code = 0x1785; // 6021
    }
}
exports.CollectionNotFoundError = CollectionNotFoundError;
codeToErrorMap.set(0x1785, CollectionNotFoundError);
nameToErrorMap.set('CollectionNotFound', CollectionNotFoundError);
/** AlreadyVerified: Collection item is already verified. */
class AlreadyVerifiedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Collection item is already verified.', program, cause);
        this.name = 'AlreadyVerified';
        this.code = 0x1786; // 6022
    }
}
exports.AlreadyVerifiedError = AlreadyVerifiedError;
codeToErrorMap.set(0x1786, AlreadyVerifiedError);
nameToErrorMap.set('AlreadyVerified', AlreadyVerifiedError);
/** AlreadyUnverified: Collection item is already unverified. */
class AlreadyUnverifiedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Collection item is already unverified.', program, cause);
        this.name = 'AlreadyUnverified';
        this.code = 0x1787; // 6023
    }
}
exports.AlreadyUnverifiedError = AlreadyUnverifiedError;
codeToErrorMap.set(0x1787, AlreadyUnverifiedError);
nameToErrorMap.set('AlreadyUnverified', AlreadyUnverifiedError);
/** UpdateAuthorityIncorrect: Incorrect leaf metadata update authority. */
class UpdateAuthorityIncorrectError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Incorrect leaf metadata update authority.', program, cause);
        this.name = 'UpdateAuthorityIncorrect';
        this.code = 0x1788; // 6024
    }
}
exports.UpdateAuthorityIncorrectError = UpdateAuthorityIncorrectError;
codeToErrorMap.set(0x1788, UpdateAuthorityIncorrectError);
nameToErrorMap.set('UpdateAuthorityIncorrect', UpdateAuthorityIncorrectError);
/** LeafAuthorityMustSign: This transaction must be signed by either the leaf owner or leaf delegate */
class LeafAuthorityMustSignError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('This transaction must be signed by either the leaf owner or leaf delegate', program, cause);
        this.name = 'LeafAuthorityMustSign';
        this.code = 0x1789; // 6025
    }
}
exports.LeafAuthorityMustSignError = LeafAuthorityMustSignError;
codeToErrorMap.set(0x1789, LeafAuthorityMustSignError);
nameToErrorMap.set('LeafAuthorityMustSign', LeafAuthorityMustSignError);
/** CollectionMustBeSized: Collection Not Compatable with Compression, Must be Sized */
class CollectionMustBeSizedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Collection Not Compatable with Compression, Must be Sized', program, cause);
        this.name = 'CollectionMustBeSized';
        this.code = 0x178a; // 6026
    }
}
exports.CollectionMustBeSizedError = CollectionMustBeSizedError;
codeToErrorMap.set(0x178a, CollectionMustBeSizedError);
nameToErrorMap.set('CollectionMustBeSized', CollectionMustBeSizedError);
/** MetadataMintMismatch: Metadata mint does not match collection mint */
class MetadataMintMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Metadata mint does not match collection mint', program, cause);
        this.name = 'MetadataMintMismatch';
        this.code = 0x178b; // 6027
    }
}
exports.MetadataMintMismatchError = MetadataMintMismatchError;
codeToErrorMap.set(0x178b, MetadataMintMismatchError);
nameToErrorMap.set('MetadataMintMismatch', MetadataMintMismatchError);
/** InvalidCollectionAuthority: Invalid collection authority */
class InvalidCollectionAuthorityError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid collection authority', program, cause);
        this.name = 'InvalidCollectionAuthority';
        this.code = 0x178c; // 6028
    }
}
exports.InvalidCollectionAuthorityError = InvalidCollectionAuthorityError;
codeToErrorMap.set(0x178c, InvalidCollectionAuthorityError);
nameToErrorMap.set('InvalidCollectionAuthority', InvalidCollectionAuthorityError);
/** InvalidDelegateRecord: Invalid delegate record pda derivation */
class InvalidDelegateRecordError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid delegate record pda derivation', program, cause);
        this.name = 'InvalidDelegateRecord';
        this.code = 0x178d; // 6029
    }
}
exports.InvalidDelegateRecordError = InvalidDelegateRecordError;
codeToErrorMap.set(0x178d, InvalidDelegateRecordError);
nameToErrorMap.set('InvalidDelegateRecord', InvalidDelegateRecordError);
/** CollectionMasterEditionAccountInvalid: Edition account doesnt match collection */
class CollectionMasterEditionAccountInvalidError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Edition account doesnt match collection', program, cause);
        this.name = 'CollectionMasterEditionAccountInvalid';
        this.code = 0x178e; // 6030
    }
}
exports.CollectionMasterEditionAccountInvalidError = CollectionMasterEditionAccountInvalidError;
codeToErrorMap.set(0x178e, CollectionMasterEditionAccountInvalidError);
nameToErrorMap.set('CollectionMasterEditionAccountInvalid', CollectionMasterEditionAccountInvalidError);
/** CollectionMustBeAUniqueMasterEdition: Collection Must Be a Unique Master Edition v2 */
class CollectionMustBeAUniqueMasterEditionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Collection Must Be a Unique Master Edition v2', program, cause);
        this.name = 'CollectionMustBeAUniqueMasterEdition';
        this.code = 0x178f; // 6031
    }
}
exports.CollectionMustBeAUniqueMasterEditionError = CollectionMustBeAUniqueMasterEditionError;
codeToErrorMap.set(0x178f, CollectionMustBeAUniqueMasterEditionError);
nameToErrorMap.set('CollectionMustBeAUniqueMasterEdition', CollectionMustBeAUniqueMasterEditionError);
/** UnknownExternalError: Could not convert external error to BubblegumError */
class UnknownExternalErrorError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Could not convert external error to BubblegumError', program, cause);
        this.name = 'UnknownExternalError';
        this.code = 0x1790; // 6032
    }
}
exports.UnknownExternalErrorError = UnknownExternalErrorError;
codeToErrorMap.set(0x1790, UnknownExternalErrorError);
nameToErrorMap.set('UnknownExternalError', UnknownExternalErrorError);
/** DecompressionDisabled: Decompression is disabled for this tree. */
class DecompressionDisabledError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Decompression is disabled for this tree.', program, cause);
        this.name = 'DecompressionDisabled';
        this.code = 0x1791; // 6033
    }
}
exports.DecompressionDisabledError = DecompressionDisabledError;
codeToErrorMap.set(0x1791, DecompressionDisabledError);
nameToErrorMap.set('DecompressionDisabled', DecompressionDisabledError);
/** MissingCollectionMintAccount: Missing collection mint account */
class MissingCollectionMintAccountError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing collection mint account', program, cause);
        this.name = 'MissingCollectionMintAccount';
        this.code = 0x1792; // 6034
    }
}
exports.MissingCollectionMintAccountError = MissingCollectionMintAccountError;
codeToErrorMap.set(0x1792, MissingCollectionMintAccountError);
nameToErrorMap.set('MissingCollectionMintAccount', MissingCollectionMintAccountError);
/** MissingCollectionMetadataAccount: Missing collection metadata account */
class MissingCollectionMetadataAccountError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing collection metadata account', program, cause);
        this.name = 'MissingCollectionMetadataAccount';
        this.code = 0x1793; // 6035
    }
}
exports.MissingCollectionMetadataAccountError = MissingCollectionMetadataAccountError;
codeToErrorMap.set(0x1793, MissingCollectionMetadataAccountError);
nameToErrorMap.set('MissingCollectionMetadataAccount', MissingCollectionMetadataAccountError);
/** CollectionMismatch: Collection mismatch */
class CollectionMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Collection mismatch', program, cause);
        this.name = 'CollectionMismatch';
        this.code = 0x1794; // 6036
    }
}
exports.CollectionMismatchError = CollectionMismatchError;
codeToErrorMap.set(0x1794, CollectionMismatchError);
nameToErrorMap.set('CollectionMismatch', CollectionMismatchError);
/** MetadataImmutable: Metadata not mutable */
class MetadataImmutableError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Metadata not mutable', program, cause);
        this.name = 'MetadataImmutable';
        this.code = 0x1795; // 6037
    }
}
exports.MetadataImmutableError = MetadataImmutableError;
codeToErrorMap.set(0x1795, MetadataImmutableError);
nameToErrorMap.set('MetadataImmutable', MetadataImmutableError);
/** PrimarySaleCanOnlyBeFlippedToTrue: Can only update primary sale to true */
class PrimarySaleCanOnlyBeFlippedToTrueError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Can only update primary sale to true', program, cause);
        this.name = 'PrimarySaleCanOnlyBeFlippedToTrue';
        this.code = 0x1796; // 6038
    }
}
exports.PrimarySaleCanOnlyBeFlippedToTrueError = PrimarySaleCanOnlyBeFlippedToTrueError;
codeToErrorMap.set(0x1796, PrimarySaleCanOnlyBeFlippedToTrueError);
nameToErrorMap.set('PrimarySaleCanOnlyBeFlippedToTrue', PrimarySaleCanOnlyBeFlippedToTrueError);
/** CreatorDidNotUnverify: Creator did not unverify the metadata */
class CreatorDidNotUnverifyError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Creator did not unverify the metadata', program, cause);
        this.name = 'CreatorDidNotUnverify';
        this.code = 0x1797; // 6039
    }
}
exports.CreatorDidNotUnverifyError = CreatorDidNotUnverifyError;
codeToErrorMap.set(0x1797, CreatorDidNotUnverifyError);
nameToErrorMap.set('CreatorDidNotUnverify', CreatorDidNotUnverifyError);
/** InvalidTokenStandard: Only NonFungible standard is supported */
class InvalidTokenStandardError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Only NonFungible standard is supported', program, cause);
        this.name = 'InvalidTokenStandard';
        this.code = 0x1798; // 6040
    }
}
exports.InvalidTokenStandardError = InvalidTokenStandardError;
codeToErrorMap.set(0x1798, InvalidTokenStandardError);
nameToErrorMap.set('InvalidTokenStandard', InvalidTokenStandardError);
/** InvalidCanopySize: Canopy size should be set bigger for this tree */
class InvalidCanopySizeError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Canopy size should be set bigger for this tree', program, cause);
        this.name = 'InvalidCanopySize';
        this.code = 0x1799; // 6041
    }
}
exports.InvalidCanopySizeError = InvalidCanopySizeError;
codeToErrorMap.set(0x1799, InvalidCanopySizeError);
nameToErrorMap.set('InvalidCanopySize', InvalidCanopySizeError);
/** InvalidLogWrapper: Invalid log wrapper program */
class InvalidLogWrapperError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid log wrapper program', program, cause);
        this.name = 'InvalidLogWrapper';
        this.code = 0x179a; // 6042
    }
}
exports.InvalidLogWrapperError = InvalidLogWrapperError;
codeToErrorMap.set(0x179a, InvalidLogWrapperError);
nameToErrorMap.set('InvalidLogWrapper', InvalidLogWrapperError);
/** InvalidCompressionProgram: Invalid compression program */
class InvalidCompressionProgramError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid compression program', program, cause);
        this.name = 'InvalidCompressionProgram';
        this.code = 0x179b; // 6043
    }
}
exports.InvalidCompressionProgramError = InvalidCompressionProgramError;
codeToErrorMap.set(0x179b, InvalidCompressionProgramError);
nameToErrorMap.set('InvalidCompressionProgram', InvalidCompressionProgramError);
/** LeafMustBeDelegated: Leaf must be delegated to someone other than the leaf owner */
class LeafMustBeDelegatedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Leaf must be delegated to someone other than the leaf owner', program, cause);
        this.name = 'LeafMustBeDelegated';
        this.code = 0x179c; // 6044
    }
}
exports.LeafMustBeDelegatedError = LeafMustBeDelegatedError;
codeToErrorMap.set(0x179c, LeafMustBeDelegatedError);
nameToErrorMap.set('LeafMustBeDelegated', LeafMustBeDelegatedError);
/** AssetIsFrozen: Asset is frozen */
class AssetIsFrozenError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Asset is frozen', program, cause);
        this.name = 'AssetIsFrozen';
        this.code = 0x179d; // 6045
    }
}
exports.AssetIsFrozenError = AssetIsFrozenError;
codeToErrorMap.set(0x179d, AssetIsFrozenError);
nameToErrorMap.set('AssetIsFrozen', AssetIsFrozenError);
/** AssetIsNonTransferable: Asset is non-transferable */
class AssetIsNonTransferableError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Asset is non-transferable', program, cause);
        this.name = 'AssetIsNonTransferable';
        this.code = 0x179e; // 6046
    }
}
exports.AssetIsNonTransferableError = AssetIsNonTransferableError;
codeToErrorMap.set(0x179e, AssetIsNonTransferableError);
nameToErrorMap.set('AssetIsNonTransferable', AssetIsNonTransferableError);
/** InvalidAuthority: Invalid authority */
class InvalidAuthorityError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Invalid authority', program, cause);
        this.name = 'InvalidAuthority';
        this.code = 0x179f; // 6047
    }
}
exports.InvalidAuthorityError = InvalidAuthorityError;
codeToErrorMap.set(0x179f, InvalidAuthorityError);
nameToErrorMap.set('InvalidAuthority', InvalidAuthorityError);
/** CollectionIsFrozen: Collection is frozen */
class CollectionIsFrozenError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Collection is frozen', program, cause);
        this.name = 'CollectionIsFrozen';
        this.code = 0x17a0; // 6048
    }
}
exports.CollectionIsFrozenError = CollectionIsFrozenError;
codeToErrorMap.set(0x17a0, CollectionIsFrozenError);
nameToErrorMap.set('CollectionIsFrozen', CollectionIsFrozenError);
/** CollectionMustHaveBubblegumPlugin: Core collections must have the Bubblegum V2 plugin on them */
class CollectionMustHaveBubblegumPluginError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Core collections must have the Bubblegum V2 plugin on them', program, cause);
        this.name = 'CollectionMustHaveBubblegumPlugin';
        this.code = 0x17a1; // 6049
    }
}
exports.CollectionMustHaveBubblegumPluginError = CollectionMustHaveBubblegumPluginError;
codeToErrorMap.set(0x17a1, CollectionMustHaveBubblegumPluginError);
nameToErrorMap.set('CollectionMustHaveBubblegumPlugin', CollectionMustHaveBubblegumPluginError);
/** NotAvailable: Feature not currently available */
class NotAvailableError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Feature not currently available', program, cause);
        this.name = 'NotAvailable';
        this.code = 0x17a2; // 6050
    }
}
exports.NotAvailableError = NotAvailableError;
codeToErrorMap.set(0x17a2, NotAvailableError);
nameToErrorMap.set('NotAvailable', NotAvailableError);
/** MissingCollectionAccount: Missing collection account */
class MissingCollectionAccountError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing collection account', program, cause);
        this.name = 'MissingCollectionAccount';
        this.code = 0x17a3; // 6051
    }
}
exports.MissingCollectionAccountError = MissingCollectionAccountError;
codeToErrorMap.set(0x17a3, MissingCollectionAccountError);
nameToErrorMap.set('MissingCollectionAccount', MissingCollectionAccountError);
/** AssetDataLengthTooLong: Asset data length too long */
class AssetDataLengthTooLongError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Asset data length too long', program, cause);
        this.name = 'AssetDataLengthTooLong';
        this.code = 0x17a4; // 6052
    }
}
exports.AssetDataLengthTooLongError = AssetDataLengthTooLongError;
codeToErrorMap.set(0x17a4, AssetDataLengthTooLongError);
nameToErrorMap.set('AssetDataLengthTooLong', AssetDataLengthTooLongError);
/** AlreadyInCollection: Item is already in the collection */
class AlreadyInCollectionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Item is already in the collection', program, cause);
        this.name = 'AlreadyInCollection';
        this.code = 0x17a5; // 6053
    }
}
exports.AlreadyInCollectionError = AlreadyInCollectionError;
codeToErrorMap.set(0x17a5, AlreadyInCollectionError);
nameToErrorMap.set('AlreadyInCollection', AlreadyInCollectionError);
/** AlreadyNotInCollection: Item is already not in a collection */
class AlreadyNotInCollectionError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Item is already not in a collection', program, cause);
        this.name = 'AlreadyNotInCollection';
        this.code = 0x17a6; // 6054
    }
}
exports.AlreadyNotInCollectionError = AlreadyNotInCollectionError;
codeToErrorMap.set(0x17a6, AlreadyNotInCollectionError);
nameToErrorMap.set('AlreadyNotInCollection', AlreadyNotInCollectionError);
/** MissingMplCoreCpiSignerAccount: Missing mpl-core CPI signer account */
class MissingMplCoreCpiSignerAccountError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Missing mpl-core CPI signer account', program, cause);
        this.name = 'MissingMplCoreCpiSignerAccount';
        this.code = 0x17a7; // 6055
    }
}
exports.MissingMplCoreCpiSignerAccountError = MissingMplCoreCpiSignerAccountError;
codeToErrorMap.set(0x17a7, MissingMplCoreCpiSignerAccountError);
nameToErrorMap.set('MissingMplCoreCpiSignerAccount', MissingMplCoreCpiSignerAccountError);
/** AssetIsNotFrozen: Asset is not frozen */
class AssetIsNotFrozenError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Asset is not frozen', program, cause);
        this.name = 'AssetIsNotFrozen';
        this.code = 0x17a8; // 6056
    }
}
exports.AssetIsNotFrozenError = AssetIsNotFrozenError;
codeToErrorMap.set(0x17a8, AssetIsNotFrozenError);
nameToErrorMap.set('AssetIsNotFrozen', AssetIsNotFrozenError);
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 */
function getMplBubblegumErrorFromCode(code, program, cause) {
    const constructor = codeToErrorMap.get(code);
    return constructor ? new constructor(program, cause) : null;
}
exports.getMplBubblegumErrorFromCode = getMplBubblegumErrorFromCode;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 */
function getMplBubblegumErrorFromName(name, program, cause) {
    const constructor = nameToErrorMap.get(name);
    return constructor ? new constructor(program, cause) : null;
}
exports.getMplBubblegumErrorFromName = getMplBubblegumErrorFromName;
//# sourceMappingURL=mplBubblegum.js.map