"use strict";
/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSplAccountCompressionErrorFromName = exports.getSplAccountCompressionErrorFromCode = exports.LeafIndexOutOfBoundsError = exports.IncorrectAccountTypeError = exports.IncorrectAccountOwnerError = exports.IncorrectAuthorityError = exports.CanopyLengthMismatchError = exports.ConcurrentMerkleTreeConstantsErrorError = exports.ZeroCopyErrorError = exports.ConcurrentMerkleTreeErrorError = exports.IncorrectLeafLengthError = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const codeToErrorMap = new Map();
const nameToErrorMap = new Map();
/** IncorrectLeafLength: Incorrect leaf length. Expected vec of 32 bytes */
class IncorrectLeafLengthError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Incorrect leaf length. Expected vec of 32 bytes', program, cause);
        this.name = 'IncorrectLeafLength';
        this.code = 0x1770; // 6000
    }
}
exports.IncorrectLeafLengthError = IncorrectLeafLengthError;
codeToErrorMap.set(0x1770, IncorrectLeafLengthError);
nameToErrorMap.set('IncorrectLeafLength', IncorrectLeafLengthError);
/** ConcurrentMerkleTreeError: Concurrent merkle tree error */
class ConcurrentMerkleTreeErrorError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Concurrent merkle tree error', program, cause);
        this.name = 'ConcurrentMerkleTreeError';
        this.code = 0x1771; // 6001
    }
}
exports.ConcurrentMerkleTreeErrorError = ConcurrentMerkleTreeErrorError;
codeToErrorMap.set(0x1771, ConcurrentMerkleTreeErrorError);
nameToErrorMap.set('ConcurrentMerkleTreeError', ConcurrentMerkleTreeErrorError);
/** ZeroCopyError: Issue zero copying concurrent merkle tree data */
class ZeroCopyErrorError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Issue zero copying concurrent merkle tree data', program, cause);
        this.name = 'ZeroCopyError';
        this.code = 0x1772; // 6002
    }
}
exports.ZeroCopyErrorError = ZeroCopyErrorError;
codeToErrorMap.set(0x1772, ZeroCopyErrorError);
nameToErrorMap.set('ZeroCopyError', ZeroCopyErrorError);
/** ConcurrentMerkleTreeConstantsError: An unsupported max depth or max buffer size constant was provided */
class ConcurrentMerkleTreeConstantsErrorError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('An unsupported max depth or max buffer size constant was provided', program, cause);
        this.name = 'ConcurrentMerkleTreeConstantsError';
        this.code = 0x1773; // 6003
    }
}
exports.ConcurrentMerkleTreeConstantsErrorError = ConcurrentMerkleTreeConstantsErrorError;
codeToErrorMap.set(0x1773, ConcurrentMerkleTreeConstantsErrorError);
nameToErrorMap.set('ConcurrentMerkleTreeConstantsError', ConcurrentMerkleTreeConstantsErrorError);
/** CanopyLengthMismatch: Expected a different byte length for the merkle tree canopy */
class CanopyLengthMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Expected a different byte length for the merkle tree canopy', program, cause);
        this.name = 'CanopyLengthMismatch';
        this.code = 0x1774; // 6004
    }
}
exports.CanopyLengthMismatchError = CanopyLengthMismatchError;
codeToErrorMap.set(0x1774, CanopyLengthMismatchError);
nameToErrorMap.set('CanopyLengthMismatch', CanopyLengthMismatchError);
/** IncorrectAuthority: Provided authority does not match expected tree authority */
class IncorrectAuthorityError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Provided authority does not match expected tree authority', program, cause);
        this.name = 'IncorrectAuthority';
        this.code = 0x1775; // 6005
    }
}
exports.IncorrectAuthorityError = IncorrectAuthorityError;
codeToErrorMap.set(0x1775, IncorrectAuthorityError);
nameToErrorMap.set('IncorrectAuthority', IncorrectAuthorityError);
/** IncorrectAccountOwner: Account is owned by a different program, expected it to be owned by this program */
class IncorrectAccountOwnerError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Account is owned by a different program, expected it to be owned by this program', program, cause);
        this.name = 'IncorrectAccountOwner';
        this.code = 0x1776; // 6006
    }
}
exports.IncorrectAccountOwnerError = IncorrectAccountOwnerError;
codeToErrorMap.set(0x1776, IncorrectAccountOwnerError);
nameToErrorMap.set('IncorrectAccountOwner', IncorrectAccountOwnerError);
/** IncorrectAccountType: Account provided has incorrect account type */
class IncorrectAccountTypeError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Account provided has incorrect account type', program, cause);
        this.name = 'IncorrectAccountType';
        this.code = 0x1777; // 6007
    }
}
exports.IncorrectAccountTypeError = IncorrectAccountTypeError;
codeToErrorMap.set(0x1777, IncorrectAccountTypeError);
nameToErrorMap.set('IncorrectAccountType', IncorrectAccountTypeError);
/** LeafIndexOutOfBounds: Leaf index of concurrent merkle tree is out of bounds */
class LeafIndexOutOfBoundsError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Leaf index of concurrent merkle tree is out of bounds', program, cause);
        this.name = 'LeafIndexOutOfBounds';
        this.code = 0x1778; // 6008
    }
}
exports.LeafIndexOutOfBoundsError = LeafIndexOutOfBoundsError;
codeToErrorMap.set(0x1778, LeafIndexOutOfBoundsError);
nameToErrorMap.set('LeafIndexOutOfBounds', LeafIndexOutOfBoundsError);
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 */
function getSplAccountCompressionErrorFromCode(code, program, cause) {
    const constructor = codeToErrorMap.get(code);
    return constructor ? new constructor(program, cause) : null;
}
exports.getSplAccountCompressionErrorFromCode = getSplAccountCompressionErrorFromCode;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 */
function getSplAccountCompressionErrorFromName(name, program, cause) {
    const constructor = nameToErrorMap.get(name);
    return constructor ? new constructor(program, cause) : null;
}
exports.getSplAccountCompressionErrorFromName = getSplAccountCompressionErrorFromName;
//# sourceMappingURL=splAccountCompression.js.map