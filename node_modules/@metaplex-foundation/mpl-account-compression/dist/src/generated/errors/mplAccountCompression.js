"use strict";
/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMplAccountCompressionErrorFromName = exports.getMplAccountCompressionErrorFromCode = exports.CanopyRightmostLeafMismatchError = exports.CanopyRootMismatchError = exports.BatchNotInitializedError = exports.TreeAlreadyInitializedError = exports.CanopyNotAllocatedError = exports.LeafIndexOutOfBoundsError = exports.IncorrectAccountTypeError = exports.IncorrectAccountOwnerError = exports.IncorrectAuthorityError = exports.CanopyLengthMismatchError = exports.ConcurrentMerkleTreeConstantsErrorError = exports.ZeroCopyErrorError = exports.ConcurrentMerkleTreeErrorError = exports.IncorrectLeafLengthError = void 0;
const umi_1 = require("@metaplex-foundation/umi");
const codeToErrorMap = new Map();
const nameToErrorMap = new Map();
/** IncorrectLeafLength: Incorrect leaf length. Expected vec of 32 bytes */
class IncorrectLeafLengthError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Incorrect leaf length. Expected vec of 32 bytes', program, cause);
        this.name = 'IncorrectLeafLength';
        this.code = 0x1770; // 6000
    }
}
exports.IncorrectLeafLengthError = IncorrectLeafLengthError;
codeToErrorMap.set(0x1770, IncorrectLeafLengthError);
nameToErrorMap.set('IncorrectLeafLength', IncorrectLeafLengthError);
/** ConcurrentMerkleTreeError: Concurrent merkle tree error */
class ConcurrentMerkleTreeErrorError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Concurrent merkle tree error', program, cause);
        this.name = 'ConcurrentMerkleTreeError';
        this.code = 0x1771; // 6001
    }
}
exports.ConcurrentMerkleTreeErrorError = ConcurrentMerkleTreeErrorError;
codeToErrorMap.set(0x1771, ConcurrentMerkleTreeErrorError);
nameToErrorMap.set('ConcurrentMerkleTreeError', ConcurrentMerkleTreeErrorError);
/** ZeroCopyError: Issue zero copying concurrent merkle tree data */
class ZeroCopyErrorError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Issue zero copying concurrent merkle tree data', program, cause);
        this.name = 'ZeroCopyError';
        this.code = 0x1772; // 6002
    }
}
exports.ZeroCopyErrorError = ZeroCopyErrorError;
codeToErrorMap.set(0x1772, ZeroCopyErrorError);
nameToErrorMap.set('ZeroCopyError', ZeroCopyErrorError);
/** ConcurrentMerkleTreeConstantsError: An unsupported max depth or max buffer size constant was provided */
class ConcurrentMerkleTreeConstantsErrorError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('An unsupported max depth or max buffer size constant was provided', program, cause);
        this.name = 'ConcurrentMerkleTreeConstantsError';
        this.code = 0x1773; // 6003
    }
}
exports.ConcurrentMerkleTreeConstantsErrorError = ConcurrentMerkleTreeConstantsErrorError;
codeToErrorMap.set(0x1773, ConcurrentMerkleTreeConstantsErrorError);
nameToErrorMap.set('ConcurrentMerkleTreeConstantsError', ConcurrentMerkleTreeConstantsErrorError);
/** CanopyLengthMismatch: Expected a different byte length for the merkle tree canopy */
class CanopyLengthMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Expected a different byte length for the merkle tree canopy', program, cause);
        this.name = 'CanopyLengthMismatch';
        this.code = 0x1774; // 6004
    }
}
exports.CanopyLengthMismatchError = CanopyLengthMismatchError;
codeToErrorMap.set(0x1774, CanopyLengthMismatchError);
nameToErrorMap.set('CanopyLengthMismatch', CanopyLengthMismatchError);
/** IncorrectAuthority: Provided authority does not match expected tree authority */
class IncorrectAuthorityError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Provided authority does not match expected tree authority', program, cause);
        this.name = 'IncorrectAuthority';
        this.code = 0x1775; // 6005
    }
}
exports.IncorrectAuthorityError = IncorrectAuthorityError;
codeToErrorMap.set(0x1775, IncorrectAuthorityError);
nameToErrorMap.set('IncorrectAuthority', IncorrectAuthorityError);
/** IncorrectAccountOwner: Account is owned by a different program, expected it to be owned by this program */
class IncorrectAccountOwnerError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Account is owned by a different program, expected it to be owned by this program', program, cause);
        this.name = 'IncorrectAccountOwner';
        this.code = 0x1776; // 6006
    }
}
exports.IncorrectAccountOwnerError = IncorrectAccountOwnerError;
codeToErrorMap.set(0x1776, IncorrectAccountOwnerError);
nameToErrorMap.set('IncorrectAccountOwner', IncorrectAccountOwnerError);
/** IncorrectAccountType: Account provided has incorrect account type */
class IncorrectAccountTypeError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Account provided has incorrect account type', program, cause);
        this.name = 'IncorrectAccountType';
        this.code = 0x1777; // 6007
    }
}
exports.IncorrectAccountTypeError = IncorrectAccountTypeError;
codeToErrorMap.set(0x1777, IncorrectAccountTypeError);
nameToErrorMap.set('IncorrectAccountType', IncorrectAccountTypeError);
/** LeafIndexOutOfBounds: Leaf index of concurrent merkle tree is out of bounds */
class LeafIndexOutOfBoundsError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Leaf index of concurrent merkle tree is out of bounds', program, cause);
        this.name = 'LeafIndexOutOfBounds';
        this.code = 0x1778; // 6008
    }
}
exports.LeafIndexOutOfBoundsError = LeafIndexOutOfBoundsError;
codeToErrorMap.set(0x1778, LeafIndexOutOfBoundsError);
nameToErrorMap.set('LeafIndexOutOfBounds', LeafIndexOutOfBoundsError);
/** CanopyNotAllocated: Tree was initialized without allocating space for the canopy */
class CanopyNotAllocatedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Tree was initialized without allocating space for the canopy', program, cause);
        this.name = 'CanopyNotAllocated';
        this.code = 0x1779; // 6009
    }
}
exports.CanopyNotAllocatedError = CanopyNotAllocatedError;
codeToErrorMap.set(0x1779, CanopyNotAllocatedError);
nameToErrorMap.set('CanopyNotAllocated', CanopyNotAllocatedError);
/** TreeAlreadyInitialized: Tree was already initialized */
class TreeAlreadyInitializedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Tree was already initialized', program, cause);
        this.name = 'TreeAlreadyInitialized';
        this.code = 0x177a; // 6010
    }
}
exports.TreeAlreadyInitializedError = TreeAlreadyInitializedError;
codeToErrorMap.set(0x177a, TreeAlreadyInitializedError);
nameToErrorMap.set('TreeAlreadyInitialized', TreeAlreadyInitializedError);
/** BatchNotInitialized: Tree header was not initialized for batch processing */
class BatchNotInitializedError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Tree header was not initialized for batch processing', program, cause);
        this.name = 'BatchNotInitialized';
        this.code = 0x177b; // 6011
    }
}
exports.BatchNotInitializedError = BatchNotInitializedError;
codeToErrorMap.set(0x177b, BatchNotInitializedError);
nameToErrorMap.set('BatchNotInitialized', BatchNotInitializedError);
/** CanopyRootMismatch: Canopy root does not match the root of the tree */
class CanopyRootMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Canopy root does not match the root of the tree', program, cause);
        this.name = 'CanopyRootMismatch';
        this.code = 0x177c; // 6012
    }
}
exports.CanopyRootMismatchError = CanopyRootMismatchError;
codeToErrorMap.set(0x177c, CanopyRootMismatchError);
nameToErrorMap.set('CanopyRootMismatch', CanopyRootMismatchError);
/** CanopyRightmostLeafMismatch: Canopy contains nodes to the right of the rightmost leaf of the tree */
class CanopyRightmostLeafMismatchError extends umi_1.ProgramError {
    constructor(program, cause) {
        super('Canopy contains nodes to the right of the rightmost leaf of the tree', program, cause);
        this.name = 'CanopyRightmostLeafMismatch';
        this.code = 0x177d; // 6013
    }
}
exports.CanopyRightmostLeafMismatchError = CanopyRightmostLeafMismatchError;
codeToErrorMap.set(0x177d, CanopyRightmostLeafMismatchError);
nameToErrorMap.set('CanopyRightmostLeafMismatch', CanopyRightmostLeafMismatchError);
/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 */
function getMplAccountCompressionErrorFromCode(code, program, cause) {
    const constructor = codeToErrorMap.get(code);
    return constructor ? new constructor(program, cause) : null;
}
exports.getMplAccountCompressionErrorFromCode = getMplAccountCompressionErrorFromCode;
/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 */
function getMplAccountCompressionErrorFromName(name, program, cause) {
    const constructor = nameToErrorMap.get(name);
    return constructor ? new constructor(program, cause) : null;
}
exports.getMplAccountCompressionErrorFromName = getMplAccountCompressionErrorFromName;
//# sourceMappingURL=mplAccountCompression.js.map